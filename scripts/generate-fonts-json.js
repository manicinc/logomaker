/**
 * scripts/generate-fonts-json.js (v1.4 - Fixed familyName generation)
 * Generates: fonts.json, inline-fonts-data.js, css/generated-font-classes.css
 * Uses original folderName for familyName to ensure consistency.
 */

const fs = require('fs');
const path = require('path');

// --- Configuration ---
const FONT_DIR_NAME = 'fonts';
const CSS_DIR_NAME = 'css';
const OUTPUT_JSON_FILENAME = 'fonts.json';
const OUTPUT_INLINE_JS_FILENAME = 'inline-fonts-data.js';
const OUTPUT_CSS_FILENAME = 'generated-font-classes.css';
const FONT_FAMILY_CLASS_PREFIX = 'font-family-';
const SUPPORTED_FONT_EXTENSIONS = ['.otf', '.ttf', '.woff', '.woff2', '.eot'];
const LICENSE_FILENAMES = ['license.txt', 'license.md', 'license', 'readme.md', 'readme.txt', 'ofl.txt'];

// --- Path Setup ---
const PROJECT_ROOT = process.cwd();
const FONTS_DIRECTORY = path.resolve(PROJECT_ROOT, FONT_DIR_NAME);
const CSS_DIRECTORY = path.resolve(PROJECT_ROOT, CSS_DIR_NAME);
const OUTPUT_JSON_PATH = path.resolve(PROJECT_ROOT, OUTPUT_JSON_FILENAME);
const OUTPUT_INLINE_JS_PATH = path.resolve(PROJECT_ROOT, OUTPUT_INLINE_JS_FILENAME);
const OUTPUT_CSS_PATH = path.resolve(CSS_DIRECTORY, OUTPUT_CSS_FILENAME);

// --- Args ---
const args = process.argv.slice(2);
const includeBase64 = args.includes('--base64');
let generatedCssRules = `/* --- Generated Font Family Classes --- */\n/* Auto-generated by generate-fonts-json.js */\n\n`;

// --- HELPER FUNCTIONS ---

// Placeholder - replace with your actual implementation
function guessWeight(filename) {
    /* ... PASTE YOUR WORKING guessWeight HERE ... */
    // Example placeholder:
    if (filename.toLowerCase().includes('bold')) return 700;
    if (filename.toLowerCase().includes('light')) return 300;
    // Add more weight checks based on common filename conventions
    return 400; // Default weight
}

// Placeholder - replace with your actual implementation
function guessStyle(filename) {
    /* ... PASTE YOUR WORKING guessStyle HERE ... */
    // Example placeholder:
    if (filename.toLowerCase().includes('italic')) return 'italic';
    if (filename.toLowerCase().includes('oblique')) return 'oblique';
    return 'normal'; // Default style
}

function formatDisplayName(name) {
    // Add spaces before capitals (CamelCase -> Camel Case) and replace hyphens/underscores
    const spacedName = name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/[-_]/g, ' ');
    // Capitalize each word
    return spacedName
        .split(' ')
        .filter(word => word.length > 0)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

function getMimeType(ext) {
    const lowerExt = ext.toLowerCase();
    switch (lowerExt) {
        case 'otf': return 'font/otf';
        case 'ttf': return 'font/ttf';
        case 'woff': return 'font/woff';
        case 'woff2': return 'font/woff2';
        case 'eot': return 'application/vnd.ms-fontobject';
        default: return 'application/octet-stream'; // Fallback
    }
}

function convertFileToBase64DataUrl(filePath, format) {
    try {
        const data = fs.readFileSync(filePath);
        const base64 = data.toString('base64');
        const mimeType = getMimeType(format);
        return `data:${mimeType};base64,${base64}`;
    } catch (error) {
        console.error(`[Error] Failed to encode file to Base64: ${filePath}`, error);
        throw error; // Re-throw to be caught later if needed
    }
}

function isDirectory(dirPath) {
    try {
        return fs.lstatSync(dirPath).isDirectory();
    } catch (error) {
        // Only warn if it's not a "file not found" error
        if (error.code !== 'ENOENT') {
            console.warn(`[Warn] Stat check warning for ${dirPath}: ${error.message}`);
        }
        return false;
    }
}

function sanitizeForClassName(name) {
    if (!name || typeof name !== 'string') {
        return '';
    }
    const sanitized = name
        .toLowerCase()
        .replace(/[\s_]+/g, '-')        // Replace spaces and underscores with hyphens
        .replace(/[^a-z0-9-]/g, '')     // Remove invalid characters
        .replace(/^[\d-]+/, '');        // Remove leading digits or hyphens

    return sanitized || 'invalid-name'; // Fallback if empty after sanitization
}

// --- END HELPER FUNCTIONS ---

// --- Main Logic ---
function generateFontsJson() {
    console.log(`[Info] Starting font generation... Target Directory: ${FONTS_DIRECTORY}`);

    if (!isDirectory(FONTS_DIRECTORY)) {
        console.error(`[Error] CRITICAL: Font directory not found at "${FONTS_DIRECTORY}". Please ensure the "${FONT_DIR_NAME}" directory exists.`);
        process.exit(1);
    }

    const allFontFamilies = [];
    let totalFilesProcessed = 0;
    let totalOriginalFileSize = 0;
    let totalBase64Size = 0;
    let skippedFilesOrFolders = 0;
    let directoriesScanned = 0;

    let fontDirectoryEntries = [];
    try {
        // Read directory entries, getting file type info directly
        fontDirectoryEntries = fs.readdirSync(FONTS_DIRECTORY, { withFileTypes: true });
    } catch (error) {
        console.error(`[Error] CRITICAL: Failed to read font directory "${FONTS_DIRECTORY}".`, error);
        process.exit(1);
    }

    // Filter to get only directories, which represent font families
    const familyDirectories = fontDirectoryEntries.filter(dirent => dirent.isDirectory());
    directoriesScanned = familyDirectories.length;

    console.log(`[Info] Found ${directoriesScanned} potential font family directories. Include Base64: ${includeBase64}.`);

    familyDirectories.forEach((subdirDirent, index) => {
        const folderName = subdirDirent.name; // Use the original folder name
        const absoluteFolderPath = path.join(FONTS_DIRECTORY, folderName);
        const relativeFolderPath = path.posix.join(FONT_DIR_NAME, folderName); // Use posix for web paths

        console.log(`\n[Info] Processing [${index + 1}/${directoriesScanned}]: "${folderName}"`);

        let filesInFolder;
        try {
            filesInFolder = fs.readdirSync(absoluteFolderPath);
        } catch (error) {
            console.warn(`[Warn] Failed to read directory "${absoluteFolderPath}". Skipping this family. Error: ${error.message}`);
            skippedFilesOrFolders++;
            return; // Skip this family directory
        }

        const variants = [];
        let licensePath = null;
        let licenseTextContent = null;
        const detectedFormats = new Set();

        filesInFolder.forEach(file => {
            const absoluteFilePath = path.join(absoluteFolderPath, file);
            const fileExtension = path.extname(file).toLowerCase();
            const format = fileExtension.substring(1); // e.g., 'ttf', 'woff2'
            const relativeFilePath = path.posix.join(relativeFolderPath, file);

            // --- Process Font Files ---
            if (SUPPORTED_FONT_EXTENSIONS.includes(fileExtension)) {
                totalFilesProcessed++;
                let fileStats;
                try {
                    fileStats = fs.statSync(absoluteFilePath);
                    if (!fileStats.isFile()) {
                        throw new Error("Entry is not a file.");
                    }
                } catch (error) {
                    console.warn(`[Warn] Failed to get stats for "${relativeFilePath}". Skipping this variant. Error: ${error.message}`);
                    skippedFilesOrFolders++;
                    return; // Skip this font file
                }

                detectedFormats.add(format);
                totalOriginalFileSize += fileStats.size;

                const weight = guessWeight(file);
                const style = guessStyle(file);
                const baseName = path.basename(file, fileExtension); // Filename without extension

                const variantData = {
                    name: baseName,
                    weight: weight,
                    style: style,
                    format: format,
                    fileSize: fileStats.size,
                };

                if (includeBase64) {
                    try {
                        variantData.dataUrl = convertFileToBase64DataUrl(absoluteFilePath, format);
                        totalBase64Size += variantData.dataUrl.length;
                    } catch (error) {
                        // Error already logged in convertFileToBase64DataUrl
                        console.warn(`[Warn] Skipping variant "${relativeFilePath}" due to Base64 encoding failure.`);
                        skippedFilesOrFolders++;
                        return; // Skip this variant
                    }
                } else {
                    // Use POSIX paths for URLs
                    variantData.url = path.posix.join(FONT_DIR_NAME, folderName, file);
                }
                variants.push(variantData);

            // --- Process License Files ---
            } else if (LICENSE_FILENAMES.includes(file.toLowerCase())) {
                if (!licensePath) { // Only grab the first license file found
                    licensePath = relativeFilePath; // Store relative path
                    if (includeBase64) {
                        try {
                            licenseTextContent = fs.readFileSync(absoluteFilePath, 'utf-8');
                        } catch (error) {
                            console.warn(`[Warn] Failed to read license file "${relativeFilePath}". Error: ${error.message}`);
                            licenseTextContent = `Error reading license: ${error.message}`; // Include error in data
                        }
                    }
                }
            }
            // Else: Ignore other file types
        }); // End loop through files in folder

        if (variants.length === 0) {
            console.warn(`[Warn] No valid font files found in "${folderName}". Skipping this family.`);
            // Don't increment skippedFilesOrFolders here, already counted during file processing
            return; // Skip this family
        }

        // Use original folder name for technical family name, format it for display
        const displayName = formatDisplayName(folderName); // For UI presentation
        const familyName = folderName; // Consistent technical identifier

        // Sort variants primarily by weight, then style, then name
        variants.sort((a, b) => {
            const weightDiff = a.weight - b.weight;
            if (weightDiff !== 0) return weightDiff;
            const styleCompare = a.style.localeCompare(b.style);
            if (styleCompare !== 0) return styleCompare;
            return a.name.localeCompare(b.name);
        });

        const familyData = {
            displayName: displayName,
            familyName: familyName,
            variants: variants,
            formats: Array.from(detectedFormats).sort(), // Sorted list of unique formats
            hasDefault: variants.some(v => v.weight === 400 && v.style === 'normal'),
            count: variants.length,
            size: variants.reduce((sum, variant) => sum + variant.fileSize, 0), // Sum of file sizes for this family
        };

        if (licensePath) {
            familyData.licenseFile = licensePath;
        }
        if (includeBase64 && licenseTextContent !== null) {
            familyData.licenseText = licenseTextContent;
        }

        allFontFamilies.push(familyData);

        // --- Generate CSS Rule for this family ---
        try {
            const className = sanitizeForClassName(familyData.familyName);
            const fullClassName = FONT_FAMILY_CLASS_PREFIX + className;
            const fontFamilyValue = `"${familyData.familyName}"`; // Quote the family name

            // Basic fallback font determination
            const lowerDisplayName = familyData.displayName.toLowerCase();
            const isScript = lowerDisplayName.includes('script') || lowerDisplayName.includes('hand');
            const isSerif = ['serif', 'times', 'garamond', 'georgia', 'palatino'].some(w => lowerDisplayName.includes(w)) || /serif$/i.test(lowerDisplayName);
            const isMono = ['mono', 'console', 'courier', 'terminal'].some(w => lowerDisplayName.includes(w)) || /mono$/i.test(lowerDisplayName);

            let fallbackFont = 'sans-serif'; // Default fallback
            if (isMono) {
                fallbackFont = 'monospace';
            } else if (isScript) {
                fallbackFont = 'cursive';
            } else if (isSerif) {
                fallbackFont = 'serif';
            }

            // Add rule to the CSS string
            generatedCssRules += `.${fullClassName} {\n`;
            generatedCssRules += `  font-family: ${fontFamilyValue}, ${fallbackFont};\n`;
            generatedCssRules += `}\n\n`;

        } catch (error) {
            console.warn(`[Warn] Failed to generate CSS rule for family "${familyData.familyName}":`, error.message);
        }

    }); // End loop through family directories

    // Sort families alphabetically by display name
    allFontFamilies.sort((a, b) => a.displayName.localeCompare(b.displayName));

    // --- Prepare Metadata ---
    const generationTime = new Date().toISOString();
    const totalFamilies = allFontFamilies.length;
    const totalVariants = allFontFamilies.reduce((sum, family) => sum + family.count, 0);
    const totalSizeMB = (totalOriginalFileSize / (1024 * 1024)).toFixed(2);
    const formatSummary = {};
    const weightSummary = {};

    const allFormatsSet = new Set();
    const weightCounts = {};
    allFontFamilies.forEach(family => {
        family.formats.forEach(fmt => allFormatsSet.add(fmt));
        family.variants.forEach(variant => {
            weightCounts[variant.weight] = (weightCounts[variant.weight] || 0) + 1;
        });
    });

    allFormatsSet.forEach(fmt => {
        formatSummary[fmt] = allFontFamilies.filter(f => f.formats.includes(fmt)).length;
    });
    // Sort weight summary by weight number
    Object.keys(weightCounts)
          .map(Number) // Convert keys to numbers for sorting
          .sort((a, b) => a - b)
          .forEach(weight => {
              weightSummary[weight] = weightCounts[weight];
          });

    const metadata = {
        generationTimestamp: generationTime,
        familyCount: totalFamilies,
        variantCount: totalVariants,
        totalOriginalSizeMB: totalSizeMB,
        base64Included: includeBase64,
        formatSummary: formatSummary, // Count of families supporting each format
        weightSummary: weightSummary  // Count of variants for each weight
    };
    if (includeBase64) {
         metadata.totalBase64SizeMB = (totalBase64Size / (1024 * 1024)).toFixed(2);
    }


    // --- Prepare JSON Output (URLs only) ---
    const jsonOutput = {
        metadata: metadata,
        fonts: allFontFamilies.map(family => ({
            displayName: family.displayName,
            familyName: family.familyName, // Use consistent technical name
            formats: family.formats,
            hasDefaultFont: family.hasDefault,
            fontCount: family.count,
            totalSize: family.size, // Size in bytes for this family
            licenseFile: family.licenseFile, // Relative path
            variants: family.variants.map(variant => {
                // Create a new object excluding dataUrl if present
                const { dataUrl, ...rest } = variant;
                // Ensure URL exists if not including base64
                if (!includeBase64 && !rest.url) {
                     rest.url = path.posix.join(FONT_DIR_NAME, family.familyName, `${variant.name}.${variant.format}`);
                     console.warn(`[Warn] URL regenerated for ${family.familyName} - ${variant.name} as it was missing.`);
                }
                return rest; // Return variant data without dataUrl
            })
        }))
    };

    // --- Prepare Inline JS Output (Base64 if requested) ---
    const inlineJsOutput = {
        metadata: metadata, // Reuse the same metadata
        fonts: allFontFamilies.map(family => ({
            displayName: family.displayName,
            familyName: family.familyName, // Use consistent technical name
            formats: family.formats,
            hasDefaultFont: family.hasDefault,
            fontCount: family.count,
            totalSize: family.size,
            licenseFile: family.licenseFile, // Relative path (even if text is included)
            licenseText: family.licenseText, // Included only if base64 was requested and file was readable
            variants: family.variants.map(variant => {
                // Create a new object excluding url if present
                const { url, ...rest } = variant;
                 // Check if dataUrl should be present but isn't (e.g., due to earlier error)
                if (includeBase64 && !rest.dataUrl) {
                    console.warn(`[Warn] Base64 dataUrl missing for variant: ${family.familyName} - ${variant.name}. Skipping variant in inline data.`);
                    return null; // Mark for filtering
                }
                 // If *not* including base64, ensure the URL is still present (should be, but double-check)
                if (!includeBase64 && !variant.url) { // Check original variant object for URL
                    rest.url = path.posix.join(FONT_DIR_NAME, family.familyName, `${variant.name}.${variant.format}`);
                    console.warn(`[Warn] URL regenerated for ${family.familyName} - ${variant.name} in inline data as it was missing.`);
                }
                return rest; // Return variant data without url
            }).filter(variant => variant !== null) // Remove variants marked as null
        }))
    };


    // --- Write Output Files ---

    // Write JSON file
    try {
        fs.writeFileSync(OUTPUT_JSON_PATH, JSON.stringify(jsonOutput, null, 2), 'utf-8'); // Pretty print JSON
        console.log(`[OK] Successfully wrote ${OUTPUT_JSON_FILENAME}`);
    } catch (error) {
        console.error(`[Error] Failed to write ${OUTPUT_JSON_FILENAME}`, error);
    }

    // Write Inline JS file
    try {
        // Wrap JSON in a JavaScript assignment
        const inlineJsContent = `window._INLINE_FONTS_DATA = ${JSON.stringify(inlineJsOutput, null, 2)};`;
        fs.writeFileSync(OUTPUT_INLINE_JS_PATH, inlineJsContent, 'utf-8');
        console.log(`[OK] Successfully wrote ${OUTPUT_INLINE_JS_FILENAME}`);
    } catch (error) {
        console.error(`[Error] Failed to write ${OUTPUT_INLINE_JS_FILENAME}`, error);
    }

    // Write CSS file
    try {
        // Ensure CSS directory exists
        if (!fs.existsSync(CSS_DIRECTORY)) {
            console.log(`[Info] CSS directory not found. Creating: ${CSS_DIRECTORY}`);
            fs.mkdirSync(CSS_DIRECTORY, { recursive: true });
        }
        console.log(`[Info] Writing ${generatedCssRules.split('\n').length - 3} CSS rules to ${OUTPUT_CSS_PATH}...`); // Approx rule count
        fs.writeFileSync(OUTPUT_CSS_PATH, generatedCssRules, 'utf-8');
        console.log(`[OK] Successfully wrote ${path.join(CSS_DIR_NAME, OUTPUT_CSS_FILENAME)}.`);
    } catch (error) {
        console.error(`[Error] Failed to write ${OUTPUT_CSS_FILENAME}`, error);
    }

    console.log('\n--- Generation Summary ---');
    console.log(`Processed ${directoriesScanned} directories.`);
    console.log(`Generated data for ${metadata.familyCount} font families.`);
    console.log(`Included ${metadata.variantCount} total font variants.`);
    console.log(`Total original font file size: ${metadata.totalOriginalSizeMB} MB`);
    if (metadata.base64Included) {
        console.log(`Total Base64 data size: ${metadata.totalBase64SizeMB} MB`);
    }
    if (skippedFilesOrFolders > 0) {
       console.log(`Skipped ${skippedFilesOrFolders} files/folders due to errors or invalid types.`);
    }
    console.log('--- Done ---');
}

// --- Execute Script ---
try {
    generateFontsJson();
} catch (error) {
    // Catch any unexpected top-level errors
    console.error("\n[Error] CRITICAL UNHANDLED EXCEPTION:", error);
    process.exit(1); // Exit with error code
}