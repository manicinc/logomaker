/**
 * scripts/generate-fonts-json.js (v1.1 - Added CSS Rule Generation)
 *
 * Scans the './fonts/' directory for font families.
 * Extracts metadata (weight, style, format).
 * Generates:
 * 1. `fonts.json`: Metadata with relative file paths.
 * 2. `inline-fonts-data.js`: JS variable, optionally with Base64 encoded fonts.
 * 3. `css/generated-font-classes.css`: CSS rules to apply font families.
 *
 * Usage (from project root):
 * node scripts/generate-fonts-json.js           # Paths only + CSS rules
 * node scripts/generate-fonts-json.js --base64  # Base64 data + CSS rules
 */

const fs = require('fs');
const path = require('path');

// --- Configuration ---
const FONT_DIR_NAME = 'fonts';
const CSS_DIR_NAME = 'css'; // Added for CSS output path
const OUTPUT_JSON_FILENAME = 'fonts.json';
const OUTPUT_INLINE_JS_FILENAME = 'inline-fonts-data.js';
const OUTPUT_CSS_FILENAME = 'generated-font-classes.css'; // Added CSS output filename
const FONT_FAMILY_CLASS_PREFIX = 'font-family-'; // Added prefix constant
const SUPPORTED_FONT_EXTENSIONS = ['.otf', '.ttf', '.woff', '.woff2', '.eot'];
const LICENSE_FILENAMES = ['license.txt', 'license.md', 'license', 'readme.md', 'readme.txt', 'ofl.txt'];

// --- Path Setup ---
const PROJECT_ROOT = process.cwd();
const FONTS_DIRECTORY = path.resolve(PROJECT_ROOT, FONT_DIR_NAME);
const CSS_DIRECTORY = path.resolve(PROJECT_ROOT, CSS_DIR_NAME); // Added CSS output directory
const OUTPUT_JSON_PATH = path.resolve(PROJECT_ROOT, OUTPUT_JSON_FILENAME);
const OUTPUT_INLINE_JS_PATH = path.resolve(PROJECT_ROOT, OUTPUT_INLINE_JS_FILENAME);
const OUTPUT_CSS_PATH = path.resolve(CSS_DIRECTORY, OUTPUT_CSS_FILENAME); // Added CSS output path

// --- Command Line Argument Processing ---
const args = process.argv.slice(2);
const includeBase64 = args.includes('--base64');
let generatedCssRules = `/* --- Generated Font Family Classes --- */\n/* Auto-generated by generate-fonts-json.js */\n\n`; // Initialize CSS string

// --- Helper Functions (Keep these as they were before) ---

function guessWeight(filename) {
    const lower = filename.toLowerCase().replace(/[-_\s]/g, '');
    const numericMatch = lower.match(/w(\d{3})/);
    if (numericMatch && numericMatch[1]) {
        const weight = parseInt(numericMatch[1], 10);
        if (weight >= 100 && weight <= 999) return weight;
    }
    const numericSeparatorMatch = lower.match(/(\d{3})(?!.*\d)/);
     if (numericSeparatorMatch && numericSeparatorMatch[1]) {
        const weight = parseInt(numericSeparatorMatch[1], 10);
        if (weight >= 100 && weight <= 999) return weight;
     }
    const weightMap = {
        'extrablack': 950, 'ultrablack': 950, 'black': 900, 'heavy': 900,
        'extrabold': 800, 'ultrabold': 800, 'bold': 700, 'semibold': 600,
        'demibold': 600, 'medium': 500, 'regular': 400, 'normal': 400,
        'book': 400, 'light': 300, 'extralight': 200, 'ultralight': 200,
        'thin': 100, 'hairline': 100,
    };
    for (const [name, value] of Object.entries(weightMap)) {
        if (lower.includes(name)) return value;
    }
    return 400;
}

function guessStyle(filename) {
    const lower = filename.toLowerCase();
    if (/\bitalic\b|[-_\s]italic/i.test(lower) || lower.endsWith('italic')) return 'italic';
    if (/\boblique\b|[-_\s]oblique/i.test(lower) || lower.endsWith('oblique')) return 'oblique';
    return 'normal';
}

function formatDisplayName(name) {
    const spacedName = name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/[-_]/g, ' ');
    return spacedName.split(' ').filter(word => word.length > 0)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
}

function getMimeType(extension) {
    const lowerExt = extension.toLowerCase();
    const mimeTypes = { 'otf': 'font/otf', 'ttf': 'font/ttf', 'woff': 'font/woff', 'woff2': 'font/woff2', 'eot': 'application/vnd.ms-fontobject' };
    return mimeTypes[lowerExt] || 'application/octet-stream';
}

function convertFileToBase64DataUrl(filePath, format) {
    try {
        const fileData = fs.readFileSync(filePath);
        const base64Data = fileData.toString('base64');
        const mimeType = getMimeType(format);
        return `data:${mimeType};base64,${base64Data}`;
    } catch (error) {
        console.error(`[Error] Failed to read or encode file: ${filePath}`, error);
        throw error;
    }
}

function isDirectory(dirPath) {
    try {
        return fs.statSync(dirPath).isDirectory();
    } catch (error) {
        if (error.code !== 'ENOENT') console.warn(`[Warning] Could not stat path "${dirPath}": ${error.message}`);
        return false;
    }
}

// NEW Helper: Sanitize for CSS class name (duplicate from settingsManager or import if modular)
function sanitizeForClassName(name) {
    if (!name || typeof name !== 'string') return '';
    return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
}

// --- Main Generation Logic ---

function generateFontsJson() {
    console.log(`[Info] Starting font generation process...`);
    console.log(`[Info] Looking for font families in: ${FONTS_DIRECTORY}`);

    if (!isDirectory(FONTS_DIRECTORY)) {
        console.error(`[Error] CRITICAL: Main "fonts" directory not found at "${FONTS_DIRECTORY}".`);
        process.exit(1);
    }

    const allFontFamilies = [];
    let totalFilesProcessed = 0, totalFileSize = 0, totalBase64Size = 0;
    let skippedFiles = 0, directoriesScanned = 0;

    let fontDirs = [];
    try {
        fontDirs = fs.readdirSync(FONTS_DIRECTORY, { withFileTypes: true });
    } catch (error) {
        console.error(`[Error] CRITICAL: Could not read fonts directory "${FONTS_DIRECTORY}".`, error);
        process.exit(1);
    }

    const familyDirs = fontDirs.filter(d => d.isDirectory());
    directoriesScanned = familyDirs.length;
    console.log(`[Info] Found ${directoriesScanned} potential font family directories.`);
    console.log(`[Info] Base64 encoding: ${includeBase64 ? 'ENABLED' : 'DISABLED'}.`);

    familyDirs.forEach((subdir, index) => {
        const folderName = subdir.name;
        const absoluteFolderPath = path.join(FONTS_DIRECTORY, folderName);
        const relativeFolderPath = path.posix.join(FONT_DIR_NAME, folderName);
        console.log(`\n[Info] Processing [${index + 1}/${directoriesScanned}]: "${folderName}"`);

        let filesInDir;
        try { filesInDir = fs.readdirSync(absoluteFolderPath); }
        catch (error) { console.warn(`[Warning] Could not read directory "${absoluteFolderPath}". Skipping.`, error.message); skippedFiles++; return; }

        const variants = [];
        let licenseFileRelativePath = null, licenseText = null;
        const formatsFound = new Set();

        filesInDir.forEach(file => {
            const absoluteFilePath = path.join(absoluteFolderPath, file);
            const fileExt = path.extname(file).toLowerCase();
            const format = fileExt.substring(1);

            if (SUPPORTED_FONT_EXTENSIONS.includes(fileExt)) {
                totalFilesProcessed++;
                let stats;
                try { stats = fs.statSync(absoluteFilePath); if (!stats.isFile()) throw new Error("Not a file"); }
                catch (statError) { console.warn(`[Warning] Could not stat font file "${relativeFolderPath}/${file}". Skipping.`, statError.message); skippedFiles++; return; }

                formatsFound.add(format);
                totalFileSize += stats.size;
                const weight = guessWeight(file);
                const style = guessStyle(file);
                const baseName = path.basename(file, fileExt);
                const variant = { name: baseName, weight, style, format, fileSize: stats.size };

                if (includeBase64) {
                    try {
                        variant.dataUrl = convertFileToBase64DataUrl(absoluteFilePath, format);
                        totalBase64Size += variant.dataUrl.length;
                    } catch (encodeError) { console.warn(`[Warning] Failed to encode "${relativeFolderPath}/${file}" to Base64. Skipping variant.`, encodeError.message); skippedFiles++; return; }
                } else { variant.url = path.posix.join(FONT_DIR_NAME, folderName, file); }
                variants.push(variant);
                // console.log(`  [Debug] Added variant: ${file} (Weight: ${weight}, Style: ${style}, Format: ${format})`); // Keep debug minimal
            } else if (LICENSE_FILENAMES.includes(file.toLowerCase())) {
                licenseFileRelativePath = path.posix.join(FONT_DIR_NAME, folderName, file);
                // console.log(`  [Debug] Found potential license file: ${file}`);
                if (includeBase64) {
                    try { licenseText = fs.readFileSync(absoluteFilePath, 'utf-8'); }
                    catch (readError) { console.warn(`[Warning] Could not read license file "${relativeFolderPath}/${file}".`, readError.message); licenseText = `Error reading license: ${readError.message}`; }
                }
            }
        });

        if (variants.length === 0) { console.warn(`[Warning] No valid font files found in "${folderName}". Skipping family.`); return; }

        const displayName = formatDisplayName(folderName);
        const familyName = displayName.replace(/\s+/g, ''); // CSS-friendly name
        variants.sort((a, b) => { /* ... keep sorting logic ... */
             if (a.weight !== b.weight) return a.weight - b.weight;
             if (a.style === 'normal' && b.style !== 'normal') return -1;
             if (a.style !== 'normal' && b.style === 'normal') return 1;
             if (a.style === 'italic' && b.style === 'oblique') return -1;
             if (a.style === 'oblique' && b.style === 'italic') return 1;
             return a.format.localeCompare(b.format);
        });

        const familyObj = {
            displayName, familyName, variants, formats: Array.from(formatsFound).sort(),
            hasDefaultFont: variants.some(v => v.weight === 400 && v.style === 'normal'),
            fontCount: variants.length, totalSize: variants.reduce((sum, v) => sum + v.fileSize, 0),
        };
        if (licenseFileRelativePath) familyObj.licenseFile = licenseFileRelativePath;
        if (includeBase64 && licenseText !== null) familyObj.licenseText = licenseText;
        allFontFamilies.push(familyObj);

        // --- GENERATE CSS RULE ---
         try {
            const sanitizedClassName = sanitizeForClassName(familyObj.familyName); // Use helper
            const cssClassName = FONT_FAMILY_CLASS_PREFIX + sanitizedClassName;
            const cssFontFamilyName = `"${familyObj.familyName}"`;
            const isScript = familyObj.familyName.toLowerCase().includes('script') || familyObj.familyName.toLowerCase().includes('hand') || familyObj.displayName.toLowerCase().includes('script');
            const isSerif = ['Garamond', 'Times', 'Serif', 'Claude', 'Plantin', 'Minion', 'Palatino', 'Caledonia', 'Century', 'Trajan', 'Sabon', 'Aster', 'Meridien', 'Trump', 'Weiss', 'Weidemann', 'Waters', 'Utopia', 'Constantia', 'Georgia'].some(serifWord => familyObj.displayName.includes(serifWord));
            const cssFallback = isScript ? 'cursive' : (isSerif ? 'serif' : 'sans-serif');

            generatedCssRules += `.${cssClassName} {\n`;
            generatedCssRules += `  font-family: ${cssFontFamilyName}, ${cssFallback} !important;\n`;
            generatedCssRules += `}\n\n`;
         } catch (cssGenError) {
             console.warn(`[Warning] Failed to generate CSS rule for ${familyObj.familyName}:`, cssGenError.message);
         }
         // --- END CSS RULE GENERATION ---

    }); // End processing directories

    allFontFamilies.sort((a, b) => a.displayName.localeCompare(b.displayName));

    // --- Prepare Final Output Data (Keep this section as is) ---
    const fontDataForJson = { /* ... keep metadata and fonts array creation ... */ 
         metadata: {
             generated: new Date().toISOString(), familyCount: allFontFamilies.length,
             totalFonts: allFontFamilies.reduce((sum, family) => sum + family.fontCount, 0),
             totalFileSizeMB: (totalFileSize / (1024 * 1024)).toFixed(2), base64Encoded: includeBase64,
             formatSummary: {}, weightSummary: {}
         },
         fonts: allFontFamilies.map(family => ({
             ...family,
             variants: family.variants.map(v => {
                 const { dataUrl, ...rest } = v;
                 if (!includeBase64 && !rest.url) rest.url = path.posix.join(FONT_DIR_NAME, family.familyName, `${v.name}.${v.format}`);
                 return rest;
             })
         }))
    };
    // Calculate summaries
    const allFormats = new Set(); const weightCounts = {};
    allFontFamilies.forEach(family => {
        family.formats.forEach(format => allFormats.add(format));
        family.variants.forEach(variant => { weightCounts[variant.weight] = (weightCounts[variant.weight] || 0) + 1; });
    });
    const formatSummary = {}; allFormats.forEach(format => { formatSummary[format] = fontDataForJson.fonts.filter(f => f.formats.includes(format)).length; });
    fontDataForJson.metadata.formatSummary = formatSummary;
    fontDataForJson.metadata.weightSummary = Object.fromEntries( Object.entries(weightCounts).sort(([a], [b]) => parseInt(a) - parseInt(b)) );

    const fontDataForInline = allFontFamilies.map(family => ({
         ...family,
         variants: family.variants.map(v => {
             const { url, ...rest } = v;
             if (includeBase64 && !rest.dataUrl) { console.warn(`[Warning] Missing dataUrl for ${family.familyName} ${v.name} in Base64 mode.`); return null; }
             else if (!includeBase64 && !v.url) { rest.url = path.posix.join(FONT_DIR_NAME, family.familyName, `${v.name}.${v.format}`); }
             return rest;
         }).filter(v => v !== null)
    }));

    // --- Write Output Files ---
    try {
        console.log(`\n[Info] Writing ${OUTPUT_JSON_FILENAME}...`);
        fs.writeFileSync(OUTPUT_JSON_PATH, JSON.stringify(fontDataForJson, null, 2), 'utf-8');
        console.log(`  [Success] Created ${OUTPUT_JSON_FILENAME}`);
    } catch (error) { console.error(`[Error] CRITICAL: Failed to write ${OUTPUT_JSON_FILENAME}`, error); }

    try {
        console.log(`[Info] Writing ${OUTPUT_INLINE_JS_FILENAME}...`);
        // USE PRETTY PRINTING FOR DEBUGGING (comment out the line below and uncomment the next one)
        // const inlineJsContent = `/** Generated by generate-fonts-json.js */\nwindow._INLINE_FONTS_DATA = window._INLINE_FONTS_DATA || ${JSON.stringify(fontDataForInline, null, includeBase64 ? null : 2)};\n`; // Minify if Base64
        const inlineJsContent = `/** Generated by generate-fonts-json.js */\nwindow._INLINE_FONTS_DATA = window._INLINE_FONTS_DATA || ${JSON.stringify(fontDataForInline, null, 2)};\n`; // ALWAYS PRETTY-PRINT (DEBUG)
        fs.writeFileSync(OUTPUT_INLINE_JS_PATH, inlineJsContent, 'utf-8');
        console.log(`  [Success] Created ${OUTPUT_INLINE_JS_FILENAME}`);
    } catch (error) { console.error(`[Error] CRITICAL: Failed to write ${OUTPUT_INLINE_JS_FILENAME}`, error); }

    // --- WRITE CSS FILE ---
     try {
        if (!fs.existsSync(CSS_DIRECTORY)) {
             console.log(`[Info] Creating CSS directory: ${CSS_DIRECTORY}`);
             fs.mkdirSync(CSS_DIRECTORY, { recursive: true });
        }
        console.log(`[Info] Writing generated font CSS rules to ${OUTPUT_CSS_PATH}...`);
        fs.writeFileSync(OUTPUT_CSS_PATH, generatedCssRules, 'utf-8');
        console.log(`  [Success] Created ${OUTPUT_CSS_FILENAME}`);
     } catch (error) {
        console.error(`[Error] CRITICAL: Failed to write ${OUTPUT_CSS_FILENAME}`, error);
     }
     // --- END CSS FILE WRITE ---

    // --- Final Summary ---
    console.log('\n--- Font Generation Summary ---');
    console.log(`- Directories Scanned: ${directoriesScanned}`);
    console.log(`- Font Families Found: ${allFontFamilies.length}`);
    console.log(`- Total Font Variants Processed: ${totalFilesProcessed}`);
    if (skippedFiles > 0) console.log(`- Files/Variants Skipped (Errors/Warnings): ${skippedFiles}`);
    console.log(`- Total Original File Size: ${fontDataForJson.metadata.totalFileSizeMB} MB`);
    if (includeBase64) {
        console.log(`- Total Base64 Data Size: ${(totalBase64Size / (1024 * 1024)).toFixed(2)} MB`);
        if (totalFileSize > 0) console.log(`- Base64 Encoding Ratio: ${(totalBase64Size / totalFileSize).toFixed(2)}x`);
    }
    console.log(`- Detected Formats: ${Array.from(allFormats).join(', ') || 'None'}`);
    // Updated output files log
    console.log(`- Output Files Generated: ${OUTPUT_JSON_FILENAME}, ${OUTPUT_INLINE_JS_FILENAME}, ${path.join(CSS_DIR_NAME, OUTPUT_CSS_FILENAME)}`);
    console.log('--- Process Complete ---');
}

// --- Execute ---
try { generateFontsJson(); }
catch (error) { console.error("\n[Error] A critical error occurred:", error); process.exit(1); }