/**
 * scripts/generate-fonts-json.js (v1.5 - URL Fix for Deploy/Dev)
 * Generates: fonts.json, inline-fonts-data.js, css/generated-font-classes.css
 * Creates inline-fonts-data.js with URLs when --base64 is false (for split-fonts).
 * Creates inline-fonts-data.js with dataUrls when --base64 is true (for portable).
 */

const fs = require('fs');
const path = require('path');

// --- Configuration ---
const FONT_DIR_NAME = 'fonts';
const CSS_DIR_NAME = 'css';
const OUTPUT_JSON_FILENAME = 'fonts.json';
const OUTPUT_INLINE_JS_FILENAME = 'inline-fonts-data.js';
const OUTPUT_CSS_FILENAME = 'generated-font-classes.css';
const FONT_FAMILY_CLASS_PREFIX = 'font-family-';
const SUPPORTED_FONT_EXTENSIONS = ['.otf', '.ttf', '.woff', '.woff2', '.eot'];
const LICENSE_FILENAMES = ['license.txt', 'license.md', 'license', 'readme.md', 'readme.txt', 'ofl.txt'];

// --- Path Setup ---
const PROJECT_ROOT = process.cwd();
const FONTS_DIRECTORY = path.resolve(PROJECT_ROOT, FONT_DIR_NAME);
const CSS_DIRECTORY = path.resolve(PROJECT_ROOT, CSS_DIR_NAME);
const OUTPUT_JSON_PATH = path.resolve(PROJECT_ROOT, OUTPUT_JSON_FILENAME);
const OUTPUT_INLINE_JS_PATH = path.resolve(PROJECT_ROOT, OUTPUT_INLINE_JS_FILENAME);
const OUTPUT_CSS_PATH = path.resolve(CSS_DIRECTORY, OUTPUT_CSS_FILENAME);

// --- Args ---
const args = process.argv.slice(2);
// Determine if Base64 encoding should be included based on args
const includeBase64 = args.includes('--base64');
// Initialize CSS string
let generatedCssRules = `/* --- Generated Font Family Classes --- */\n/* Auto-generated by generate-fonts-json.js */\n\n`;

// --- HELPER FUNCTIONS ---

// Guess font weight based on filename (User needs to provide or refine this)
function guessWeight(filename) {
    const lower = filename.toLowerCase();
    if (lower.includes('thin') || lower.includes('100')) return 100;
    if (lower.includes('extralight') || lower.includes('extralight') || lower.includes('200')) return 200;
    if (lower.includes('light') || lower.includes('300')) return 300;
    if (lower.includes('book') || lower.includes('roman')) return 400; // Often map to regular
    if (lower.includes('medium') || lower.includes('500')) return 500;
    if (lower.includes('semibold') || lower.includes('demibold') || lower.includes('600')) return 600;
    if (lower.includes('bold') || lower.includes('700')) return 700;
    if (lower.includes('extrabold') || lower.includes('ultrabold') || lower.includes('800')) return 800;
    if (lower.includes('black') || lower.includes('heavy') || lower.includes('900')) return 900;
    return 400; // Default to Normal/Regular
}

// Guess font style based on filename (User needs to provide or refine this)
function guessStyle(filename) {
    const lower = filename.toLowerCase();
    if (lower.includes('italic')) return 'italic';
    if (lower.includes('oblique')) return 'oblique';
    return 'normal'; // Default style
}

// Format display name from folder name
function formatDisplayName(name) {
    const spacedName = name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/[-_]/g, ' ');
    return spacedName.split(' ').filter(word => word.length > 0)
           .map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

// Get MIME type for font formats
function getMimeType(ext) {
    const lowerExt = ext.toLowerCase().substring(1); // remove dot
    switch (lowerExt) {
        case 'otf': return 'font/otf';
        case 'ttf': return 'font/ttf';
        case 'woff': return 'font/woff';
        case 'woff2': return 'font/woff2';
        case 'eot': return 'application/vnd.ms-fontobject';
        default: return 'application/octet-stream';
    }
}

// Convert file to Base64 data URL
function convertFileToBase64DataUrl(filePath, format) {
    try {
        const data = fs.readFileSync(filePath);
        const base64 = data.toString('base64');
        const mimeType = getMimeType(`.${format}`); // Pass format like 'woff2'
        return `data:${mimeType};base64,${base64}`;
    } catch (error) {
        console.error(`[Error] Failed Base64 encode: ${filePath}`, error);
        throw error; // Re-throw
    }
}

// Check if path is a directory
function isDirectory(dirPath) {
    try { return fs.lstatSync(dirPath).isDirectory(); }
    catch (error) { if (error.code !== 'ENOENT') { console.warn(`[Warn] Stat check warning for ${dirPath}: ${error.message}`); } return false; }
}

// Sanitize name for CSS class usage
function sanitizeForClassName(name) {
     if (!name || typeof name !== 'string') return '';
     const sanitized = name.toLowerCase().replace(/[\s_]+/g, '-').replace(/[^a-z0-9-]/g, '').replace(/^[\d-]+/, '');
     return sanitized || 'invalid-name';
}

// --- Main Logic ---
function generateFontsJson() {
    console.log(`[Info] Starting font generation... Target Directory: ${FONTS_DIRECTORY}`);
    if (!isDirectory(FONTS_DIRECTORY)) { console.error(`[Error] CRITICAL: Font directory not found: "${FONTS_DIRECTORY}"`); process.exit(1); }

    const allFontFamilies = [];
    let totalFilesProcessed = 0, totalOriginalFileSize = 0, totalBase64Size = 0;
    let skippedFilesOrFolders = 0, directoriesScanned = 0;
    let fontDirectoryEntries;

    try { fontDirectoryEntries = fs.readdirSync(FONTS_DIRECTORY, { withFileTypes: true }); }
    catch (error) { console.error(`[Error] CRITICAL: Failed read font directory "${FONTS_DIRECTORY}".`, error); process.exit(1); }

    const familyDirectories = fontDirectoryEntries.filter(dirent => dirent.isDirectory());
    directoriesScanned = familyDirectories.length;
    console.log(`[Info] Found ${directoriesScanned} potential font family directories. Include Base64: ${includeBase64}.`);

    // --- Pass 1: Gather data for all families and variants ---
    familyDirectories.forEach((subdirDirent, index) => {
        const folderName = subdirDirent.name;
        const absoluteFolderPath = path.join(FONTS_DIRECTORY, folderName);
        const relativeFolderPath = path.posix.join(FONT_DIR_NAME, folderName); // Use posix for web paths

        // console.log(`\n[Info] Processing [${index + 1}/${directoriesScanned}]: "${folderName}"`); // Too verbose for build log

        let filesInFolder;
        try { filesInFolder = fs.readdirSync(absoluteFolderPath); }
        catch (error) { console.warn(`[Warn] Failed read dir "${absoluteFolderPath}". Skip family. Err: ${error.message}`); skippedFilesOrFolders++; return; }

        const variants = [];
        let licensePath = null;
        let licenseTextContent = null; // Only read if includeBase64
        const detectedFormats = new Set();

        filesInFolder.forEach(file => {
            const absoluteFilePath = path.join(absoluteFolderPath, file);
            const fileExtension = path.extname(file).toLowerCase();
            const format = fileExtension.substring(1);
            const relativeFilePath = path.posix.join(relativeFolderPath, file);

            if (SUPPORTED_FONT_EXTENSIONS.includes(fileExtension)) {
                totalFilesProcessed++;
                let fileStats;
                try { fileStats = fs.statSync(absoluteFilePath); if (!fileStats.isFile()) throw new Error("Not a file."); }
                catch (error) { console.warn(`[Warn] Stat fail "${relativeFilePath}". Skip variant. Err: ${error.message}`); skippedFilesOrFolders++; return; }

                detectedFormats.add(format);
                totalOriginalFileSize += fileStats.size;

                const weight = guessWeight(file);
                const style = guessStyle(file);
                const baseName = path.basename(file, fileExtension);

                const variantData = { name: baseName, weight, style, format, fileSize: fileStats.size };

                // Add EITHER dataUrl OR url based on the flag
                if (includeBase64) { // PORTABLE
                    try {
                        variantData.dataUrl = convertFileToBase64DataUrl(absoluteFilePath, format);
                        totalBase64Size += variantData.dataUrl.length;
                    } catch (error) {
                        console.warn(`[Warn] Skipping variant "${relativeFilePath}" due to Base64 failure.`);
                        skippedFilesOrFolders++; return; // Skip this variant if encoding fails
                    }
                } else { // DEPLOY / DEV
                    variantData.url = path.posix.join(FONT_DIR_NAME, folderName, file); // Add URL
                }
                variants.push(variantData);

            } else if (LICENSE_FILENAMES.includes(file.toLowerCase())) {
                if (!licensePath) { // Only grab the first license found
                    licensePath = relativeFilePath;
                    if (includeBase64) { // Only read content if embedding
                        try { licenseTextContent = fs.readFileSync(absoluteFilePath, 'utf-8'); }
                        catch (error) { console.warn(`[Warn] Failed read license "${relativeFilePath}". Err: ${error.message}`); licenseTextContent = `Error reading: ${error.message}`; }
                    }
                }
            }
        }); // End loop files in folder

        if (variants.length > 0) { // Only add family if it has variants initially
            const displayName = formatDisplayName(folderName);
            const familyName = folderName;
            variants.sort((a, b) => { /* ... weight -> style -> name sorting ... */ const wd=a.weight-b.weight;if(wd!==0)return wd;const sc=a.style.localeCompare(b.style);if(sc!==0)return sc;return a.name.localeCompare(b.name); });
            allFontFamilies.push({
                displayName, familyName, variants,
                formats: Array.from(detectedFormats).sort(),
                hasDefault: variants.some(v => v.weight === 400 && v.style === 'normal'),
                count: variants.length, size: variants.reduce((s, v) => s + v.fileSize, 0),
                licenseFile: licensePath,
                ...(includeBase64 && licenseTextContent !== null && { licenseText: licenseTextContent }) // Conditionally add licenseText
            });
            // Generate CSS Rule
             try { const className=sanitizeForClassName(familyName); const fullClassName=FONT_FAMILY_CLASS_PREFIX+className; const fontFamilyValue=`"${familyName}"`; const ld=displayName.toLowerCase(); const isScript=ld.includes('script')||ld.includes('hand'); const isSerif=['serif','times','garamond','georgia','palatino'].some(w=>ld.includes(w))||/serif$/i.test(ld); const isMono=['mono','console','courier','terminal'].some(w=>ld.includes(w))||/mono$/i.test(ld); let fallbackFont='sans-serif'; if(isMono)fallbackFont='monospace';else if(isScript)fallbackFont='cursive';else if(isSerif)fallbackFont='serif'; generatedCssRules+=`.${fullClassName} {\n  font-family: ${fontFamilyValue}, ${fallbackFont};\n}\n\n`; } catch(e){ console.warn(`[Warn] CSS rule gen fail "${familyName}":`, e.message); }
        }
    }); // End loop family directories

    // --- Pass 2: Process gathered data for output files ---
    allFontFamilies.sort((a, b) => a.displayName.localeCompare(b.displayName));

    // --- Prepare Inline JS Output Data ---
    console.log('[Info] Preparing data for inline-fonts-data.js...');
    const processedFontsForInline = allFontFamilies.map(family => {
        const processedVariants = family.variants.map(variant => {
            const variantOutput = { ...variant };
            if (includeBase64) { // PORTABLE
                delete variantOutput.url;
                if (!variantOutput.dataUrl) { console.warn(`[Warn] Base64 dataUrl missing for ${family.familyName}-${variant.name}. Skipping inline.`); return null; }
            } else { // DEPLOY/DEV
                delete variantOutput.dataUrl;
                if (!variantOutput.url) { variantOutput.url = path.posix.join(FONT_DIR_NAME, family.familyName, `${variant.name}.${variant.format}`); console.warn(`[Warn] URL regenerated for ${family.familyName}-${variant.name}.`); }
            }
            return variantOutput;
        }).filter(v => v !== null);

        if (processedVariants.length === 0) { console.warn(`[Warn] Family "${family.familyName}" skipped in inline output (no valid variants).`); return null; }

        return {
            displayName: family.displayName, familyName: family.familyName, formats: family.formats,
            hasDefaultFont: family.hasDefault, fontCount: processedVariants.length, totalSize: family.size,
            licenseFile: family.licenseFile, licenseText: family.licenseText,
            variants: processedVariants
        };
    }).filter(f => f !== null);

    // --- Calculate Final Metadata Based on Processed Fonts ---
    const generationTime = new Date().toISOString();
    const finalFamilyCount = processedFontsForInline.length;
    const finalVariantCount = processedFontsForInline.reduce((sum, f) => sum + f.fontCount, 0);
    const totalSizeMB_original = (totalOriginalFileSize / (1024 * 1024)).toFixed(2);
    const formatSummary = {}; const weightSummary = {}; const allFormatsSet = new Set(); const weightCounts = {};
    processedFontsForInline.forEach(f => { f.formats.forEach(fmt => allFormatsSet.add(fmt)); f.variants.forEach(v => { weightCounts[v.weight] = (weightCounts[v.weight] || 0) + 1; }); });
    allFormatsSet.forEach(fmt => { formatSummary[fmt] = processedFontsForInline.filter(f => f.formats.includes(fmt)).length; });
    Object.keys(weightCounts).map(Number).sort((a, b) => a - b).forEach(w => { weightSummary[w] = weightCounts[w]; });

    const finalMetadata = {
        generationTimestamp: generationTime, familyCount: finalFamilyCount, variantCount: finalVariantCount,
        totalOriginalSizeMB: totalSizeMB_original, base64Included: includeBase64,
        formatSummary: formatSummary, weightSummary: weightSummary
    };
    if (includeBase64) { finalMetadata.totalBase64SizeMB = (totalBase64Size / (1024 * 1024)).toFixed(2); }
    console.log(`[Info] Calculated final metadata: ${finalFamilyCount} families, ${finalVariantCount} variants.`);

    // --- Construct Final Output Objects ---
     const inlineJsOutput = { metadata: finalMetadata, fonts: processedFontsForInline };
     const jsonOutput = { // fonts.json primarily needs URLs
        metadata: finalMetadata,
        fonts: allFontFamilies.map(f => ({
            displayName: f.displayName, familyName: f.familyName, formats: f.formats,
            hasDefaultFont: f.hasDefault, fontCount: f.count, totalSize: f.size, licenseFile: f.licenseFile,
            variants: f.variants.map(v => { const { dataUrl, ...rest } = v; if (!rest.url) { rest.url = path.posix.join(FONT_DIR_NAME, f.familyName, `${v.name}.${v.format}`); console.warn(`[Warn] URL regen in fonts.json for ${f.familyName}-${v.name}.`); } return rest; })
        }))
     };

    // --- Write Output Files ---
    try { fs.writeFileSync(OUTPUT_JSON_PATH, JSON.stringify(jsonOutput, null, 2), 'utf-8'); console.log(`[OK] Wrote ${OUTPUT_JSON_FILENAME}`); } catch (e) { console.error(`[Error] Write fail ${OUTPUT_JSON_FILENAME}`, e); }
    try { const jsContent = `window._INLINE_FONTS_DATA = ${JSON.stringify(inlineJsOutput, null, 2)};`; fs.writeFileSync(OUTPUT_INLINE_JS_PATH, jsContent, 'utf-8'); console.log(`[OK] Wrote ${OUTPUT_INLINE_JS_FILENAME}`); } catch (e) { console.error(`[Error] Write fail ${OUTPUT_INLINE_JS_FILENAME}`, e); }
    try { if (!fs.existsSync(CSS_DIRECTORY)) { fs.mkdirSync(CSS_DIRECTORY, { recursive: true }); } console.log(`[Info] Writing ${generatedCssRules.split('\n').length - 3} CSS rules to ${OUTPUT_CSS_PATH}...`); fs.writeFileSync(OUTPUT_CSS_PATH, generatedCssRules, 'utf-8'); console.log(`[OK] Wrote ${path.join(CSS_DIR_NAME, OUTPUT_CSS_FILENAME)}.`); } catch (e) { console.error(`[Error] Write fail ${OUTPUT_CSS_FILENAME}`, e); }

    // --- Generation Summary ---
    console.log('\n--- Generation Summary ---');
    console.log(`Processed ${directoriesScanned} initial directories.`);
    console.log(`Generated data for ${finalMetadata.familyCount} font families (with valid variants).`);
    console.log(`Included ${finalMetadata.variantCount} total font variants (in final output).`);
    console.log(`Total original font file size: ${finalMetadata.totalOriginalSizeMB} MB`);
    if (finalMetadata.base64Included) { console.log(`Total Base64 data size: ${finalMetadata.totalBase64SizeMB} MB`); }
    if (skippedFilesOrFolders > 0) { console.log(`Skipped ${skippedFilesOrFolders} files/variants during initial processing.`); }
    console.log('--- Done ---');
} // --- End of generateFontsJson function ---

// --- Execute Script ---
try {
    generateFontsJson();
} catch (error) {
    console.error("\n[Error] CRITICAL UNHANDLED EXCEPTION:", error);
    process.exit(1);
}