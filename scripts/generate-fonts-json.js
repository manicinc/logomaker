/**
 * scripts/generate-fonts-json.js (v1.9 - True Hybrid Output FIX)
 * Generates: fonts.json (URLs), inline-fonts-data.js (ALWAYS contains url + dataUrl), css/generated-font-classes.css
 * The --base64 flag now only controls the 'base64Included' METADATA flag in inline-fonts-data.js.
 * The actual JS file content ALWAYS includes both URL and dataUrl (if available).
 * Includes robustness checks.
 */

const fs = require('fs');
const path = require('path');

// --- Configuration ---
const FONT_DIR_NAME = 'fonts';
const CSS_DIR_NAME = 'css';
const OUTPUT_JSON_FILENAME = 'fonts.json'; // Contains URL-based data
const OUTPUT_INLINE_JS_FILENAME = 'inline-fonts-data.js'; // Contains BOTH URL + dataUrl
const OUTPUT_CSS_FILENAME = 'generated-font-classes.css';
const FONT_FAMILY_CLASS_PREFIX = 'font-family-';
const SUPPORTED_FONT_EXTENSIONS = ['.otf', '.ttf', '.woff', '.woff2', '.eot'];
const LICENSE_FILENAMES = ['license.txt', 'license.md', 'license', 'readme.md', 'readme.txt', 'ofl.txt'];

// --- Path Setup ---
const PROJECT_ROOT = process.cwd();
const FONTS_DIRECTORY = path.resolve(PROJECT_ROOT, FONT_DIR_NAME);
const CSS_DIRECTORY = path.resolve(PROJECT_ROOT, CSS_DIR_NAME);
const OUTPUT_JSON_PATH = path.resolve(PROJECT_ROOT, OUTPUT_JSON_FILENAME);
const OUTPUT_INLINE_JS_PATH = path.resolve(PROJECT_ROOT, OUTPUT_INLINE_JS_FILENAME);
const OUTPUT_CSS_PATH = path.resolve(CSS_DIRECTORY, OUTPUT_CSS_FILENAME);

// --- Args ---
const args = process.argv.slice(2);
const includeBase64FlagForMetadata = args.includes('--base64');
let generatedCssRules = `/* --- Generated Font Family Classes --- */\n/* Auto-generated by generate-fonts-json.js */\n\n`;

// --- HELPER FUNCTIONS ---

function guessWeight(filename) {
    if (!filename || typeof filename !== 'string') return 400;
    const lower = filename.toLowerCase();
    if (lower.includes('thin') || lower.includes('100')) return 100;
    if (lower.includes('extralight') || lower.includes('ultralight') || lower.includes('200')) return 200;
    if (lower.includes('light') || lower.includes('300')) return 300;
    if (lower.includes('book') || lower.includes('roman') || lower.includes('regular') || !lower.match(/(?:bold|medium|light|thin|black|heavy|italic|oblique|\d{3})/)) return 400;
    if (lower.includes('medium') || lower.includes('500')) return 500;
    if (lower.includes('semibold') || lower.includes('demibold') || lower.includes('600')) return 600;
    if (lower.includes('bold') || lower.includes('700')) return 700;
    if (lower.includes('extrabold') || lower.includes('ultrabold') || lower.includes('800')) return 800;
    if (lower.includes('black') || lower.includes('heavy') || lower.includes('900')) return 900;
    return 400;
}

function guessStyle(filename) {
    if (!filename || typeof filename !== 'string') return 'normal';
    const lower = filename.toLowerCase();
    if (lower.includes('italic') || lower.includes('-it')) return 'italic';
    if (lower.includes('oblique')) return 'oblique';
    return 'normal';
}

function formatDisplayName(name) {
    if (!name || typeof name !== 'string' || name.trim() === '') {
        // console.warn(`[formatDisplayName] Received invalid input name: "${name}". Returning original.`);
        return String(name || '');
    }
    try {
        const spacedName = name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/[-_]/g, ' ');
        return spacedName.split(' ').filter(word => word && word.length > 0)
               .map(word => (word.charAt(0)?.toUpperCase() ?? '') + word.slice(1)).join(' ');
    } catch (error) { console.error(`[formatDisplayName] Error processing name "${name}":`, error); return String(name); }
}

function getMimeType(ext) {
    if (!ext || typeof ext !== 'string') return 'application/octet-stream';
    const lowerExt = ext.toLowerCase().substring(1);
    switch (lowerExt) {
        case 'otf': return 'font/otf'; case 'ttf': return 'font/ttf';
        case 'woff': return 'font/woff'; case 'woff2': return 'font/woff2';
        case 'eot': return 'application/vnd.ms-fontobject';
        default: return 'application/octet-stream';
    }
}

function isDirectory(dirPath) {
    // console.log(`[isDirectory Check] Checking path: "${dirPath}"`);
    if (!dirPath) return false;
    try { const stats = fs.lstatSync(dirPath); return stats.isDirectory(); }
    catch (error) { if (error.code !== 'ENOENT') { console.error(`[isDirectory Check] Error for "${dirPath}":`, error.code); } return false; }
}

function sanitizeForClassName(name) {
     if (!name || typeof name !== 'string') return 'invalid-name';
     const sanitized = name.toLowerCase().replace(/[\s_]+/g, '-').replace(/[^a-z0-9-]/g, '').replace(/^[\d-]+/, '');
     return sanitized || 'invalid-name-fallback';
 }

function convertFileToBase64DataUrl(filePath, format) {
    try {
        if (!fs.existsSync(filePath)) { console.error(`[Error] Base64 encode failed: File not found at ${filePath}`); return null; }
        const data = fs.readFileSync(filePath); const base64 = data.toString('base64');
        const mimeType = getMimeType(`.${format}`); return `data:${mimeType};base64,${base64}`;
    } catch (error) { console.error(`[Error] Failed Base64 encode for: ${filePath}`, error); return null; }
}


// --- Main Logic ---
function generateFontsJson() {
    console.log(`[Info] Starting font generation (v1.9 - Hybrid Output)...`);
    const currentCwd = process.cwd(); const resolvedFontsDir = path.resolve(currentCwd, FONT_DIR_NAME);
    console.log(`[Info] Resolved Target Directory: "${resolvedFontsDir}"`);
    if (!fs.existsSync(resolvedFontsDir)) { console.error(`[Error] CRITICAL: Directory NOT FOUND: "${resolvedFontsDir}"`); process.exit(1); }
    if (!isDirectory(resolvedFontsDir)) { console.error(`[Error] CRITICAL: Path exists but is NOT a directory: "${resolvedFontsDir}"`); process.exit(1); }
    console.log(`[Info] Successfully verified font directory: "${resolvedFontsDir}"`);

    const allFontFamilies = []; let totalFilesProcessed = 0, totalOriginalFileSize = 0, totalBase64Size = 0;
    let skippedFilesOrFolders = 0, directoriesScanned = 0;
    let fontDirectoryEntries;

    try { fontDirectoryEntries = fs.readdirSync(resolvedFontsDir, { withFileTypes: true }); }
    catch (error) { console.error(`[Error] CRITICAL: Failed read font directory "${resolvedFontsDir}".`, error); process.exit(1); }

    const familyDirectories = fontDirectoryEntries.filter(dirent => dirent.isDirectory());
    directoriesScanned = familyDirectories.length;
    console.log(`[Info] Found ${directoriesScanned} directories. Generating URL & attempting Base64 for all.`);

    // --- Pass 1: Gather data ---
    familyDirectories.forEach((subdirDirent, index) => {
        const folderName = subdirDirent.name; const absoluteFolderPath = path.join(resolvedFontsDir, folderName);
        try {
            let filesInFolder; try { filesInFolder = fs.readdirSync(absoluteFolderPath); } catch (readDirError) { console.warn(`[Warn] Skip Family "${folderName}": Failed read dir. Err: ${readDirError.message}`); skippedFilesOrFolders++; return; }
            const variants = []; let licensePath = null; let licenseTextContent = null; const detectedFormats = new Set();

            filesInFolder.forEach(file => {
                const absoluteFilePath = path.join(absoluteFolderPath, file); const fileExtension = path.extname(file).toLowerCase();
                if (SUPPORTED_FONT_EXTENSIONS.includes(fileExtension)) {
                    const format = fileExtension.substring(1); const relativeFilePath = path.posix.join(FONT_DIR_NAME, folderName, file); totalFilesProcessed++; let fileStats;
                    try { fileStats = fs.statSync(absoluteFilePath); if (!fileStats.isFile()) throw new Error("Not a file."); } catch (error) { console.warn(`[Warn] Skip Variant "${relativeFilePath}": Stat fail. Err: ${error.message}`); skippedFilesOrFolders++; return; }
                    detectedFormats.add(format); totalOriginalFileSize += fileStats.size;
                    const weight = guessWeight(file); const style = guessStyle(file); const baseName = path.basename(file, fileExtension);
                    const variantData = { name: baseName, weight, style, format, fileSize: fileStats.size };
                    variantData.url = path.posix.join(FONT_DIR_NAME, folderName, file); // Always add URL
                    const generatedDataUrl = convertFileToBase64DataUrl(absoluteFilePath, format); // Always attempt Base64
                    variantData.dataUrl = generatedDataUrl; // Assign string or null
                    if (generatedDataUrl) totalBase64Size += generatedDataUrl.length; else console.warn(`[Warn] Base64 failed for ${relativeFilePath}. dataUrl is null.`);
                    variants.push(variantData);
                } else if (LICENSE_FILENAMES.includes(file.toLowerCase())) { if (!licensePath) { licensePath = relativeFilePath; try { licenseTextContent = fs.readFileSync(absoluteFilePath, 'utf-8'); } catch (error) { licenseTextContent = `Error reading: ${error.message}`; } } }
            });

            if (variants.length > 0) {
                const familyName = folderName; const displayName = formatDisplayName(folderName);
                if (typeof displayName !== 'string') { console.error(`[FATAL PUSH ERROR] Skipping family "${folderName}" due to invalid displayName.`); skippedFilesOrFolders++; return; }
                variants.sort((a, b) => { /*...*/ }); // Keep sort
                allFontFamilies.push({ displayName, familyName, variants, formats: Array.from(detectedFormats).sort(), hasDefault: variants.some(v => v.weight === 400 && v.style === 'normal'), count: variants.length, size: variants.reduce((s, v) => s + v.fileSize, 0), licenseFile: licensePath, licenseText: licenseTextContent });
                try { const className = sanitizeForClassName(familyName); /*...*/ generatedCssRules += `.${FONT_FAMILY_CLASS_PREFIX + className} { /*...*/ }\n\n`; } catch (e) { /*...*/ }
            } else { skippedFilesOrFolders++; }
        } catch (familyProcessingError) { console.error(`\n--- ERROR PROCESSING FAMILY FOLDER: "${folderName}" ---\n`, familyProcessingError); skippedFilesOrFolders++; }
    }); // End loop family directories


    // --- Pass 2: Process gathered data ---

    // PRE-SORT CHECK
    console.log(`[DEBUG] Checking ${allFontFamilies.length} entries in allFontFamilies before sort...`);
    let invalidEntries = 0; /* ... keep pre-sort check loop ... */
    if (invalidEntries > 0) { console.error(`[FATAL PRE-SORT] ${invalidEntries} invalid entries found. Cannot proceed.`); process.exit(1); }
    else { console.log(`[DEBUG PRE-SORT] All ${allFontFamilies.length} entries seem valid for sorting.`); }

    // SORT
    console.log('[DEBUG] Sorting allFontFamilies...');
    try { allFontFamilies.sort((a, b) => { /* ... keep robust sort comparator ... */ }); console.log('[DEBUG] Sorting completed.'); }
    catch (sortError) { console.error("[FATAL] Error during sort:", sortError); process.exit(1); }


    // --- Prepare Inline JS Output Data (NOW ALWAYS includes url + dataUrl) ---
    console.log(`[Info] Preparing data for ${OUTPUT_INLINE_JS_FILENAME} (includes URL + Base64)...`);
    const processedFontsForInline = allFontFamilies.map(family => {
         const validVariants = family.variants.filter(variant => !!variant?.url); // Ensure URL exists
         if (validVariants.length === 0) { return null; }
         // Return the family object with its VALID variants (containing url and potentially null/string dataUrl)
         return { ...family, variants: validVariants };
    }).filter(f => f !== null);


    // --- Calculate Final Metadata ---
    const generationTime = new Date().toISOString();
    const finalFamilyCount = processedFontsForInline.length; // Use count AFTER filtering
    const finalVariantCount = processedFontsForInline.reduce((sum, f) => sum + f.variants.length, 0);
    const totalSizeMB_original = (totalOriginalFileSize / (1024 * 1024)).toFixed(2);
    const formatSummary = {}; const weightSummary = {}; /* ... keep summary calculation using processedFontsForInline ... */
    const finalMetadata = {
         generationTimestamp: generationTime, familyCount: finalFamilyCount, variantCount: finalVariantCount,
         totalOriginalSizeMB: totalSizeMB_original,
         // Set metadata flag based on the COMMAND LINE ARG used when this script was RUN
         base64Included: includeBase64FlagForMetadata,
         formatSummary: formatSummary, weightSummary: weightSummary
    };
    if (totalBase64Size > 0) { finalMetadata.totalBase64SizeMB = (totalBase64Size / (1024 * 1024)).toFixed(2); }
    console.log(`[Info] Calculated final metadata for ${OUTPUT_INLINE_JS_FILENAME}: ${finalFamilyCount} families, ${finalVariantCount} variants.`);


    // --- Construct Final Output Objects ---
    // inlineJsOutput NOW contains variants with BOTH url and dataUrl (if available)
    const inlineJsOutput = { metadata: finalMetadata, fonts: processedFontsForInline };

    // Prepare fonts.json Output (Still URL-only)
    console.log(`[Info] Preparing URL-based data for ${OUTPUT_JSON_FILENAME}...`);
    const fontsForJsonFile = allFontFamilies.map(f => ({
            displayName: f.displayName, familyName: f.familyName, formats: f.formats, hasDefaultFont: f.hasDefault,
            fontCount: f.count, totalSize: f.size, licenseFile: f.licenseFile,
            variants: f.variants.map(v => { const { dataUrl, licenseText, ...rest } = v; if (!rest.url) { rest.url = path.posix.join(FONT_DIR_NAME, f.familyName, `${v.name}.${v.format}`); console.warn(`[Warn fonts.json] URL regenerated for ${f.familyName}-${v.name}.`); } return rest; })
        }));
    const jsonOutput = { metadata: { ...finalMetadata, base64Included: false, familyCount: fontsForJsonFile.length, variantCount: fontsForJsonFile.reduce((sum, f) => sum + f.variants.length, 0) }, fonts: fontsForJsonFile };


    // --- Write Output Files ---
    try { const jsContent = `window._INLINE_FONTS_DATA = ${JSON.stringify(inlineJsOutput, null, 2)};`; fs.writeFileSync(OUTPUT_INLINE_JS_PATH, jsContent, 'utf-8'); console.log(`[OK] Wrote ${OUTPUT_INLINE_JS_FILENAME}`); } catch (e) { console.error(`[Error] Write fail ${OUTPUT_INLINE_JS_FILENAME}`, e); }
    try { fs.writeFileSync(OUTPUT_JSON_PATH, JSON.stringify(jsonOutput, null, 2), 'utf-8'); console.log(`[OK] Wrote ${OUTPUT_JSON_FILENAME}`); } catch (e) { console.error(`[Error] Write fail ${OUTPUT_JSON_FILENAME}`, e); }
    try { if (!fs.existsSync(CSS_DIRECTORY)) { fs.mkdirSync(CSS_DIRECTORY, { recursive: true }); } fs.writeFileSync(OUTPUT_CSS_PATH, generatedCssRules, 'utf-8'); console.log(`[OK] Wrote ${path.join(CSS_DIR_NAME, OUTPUT_CSS_FILENAME)} (${generatedCssRules.split('\n').length - 3} rules).`); } catch (e) { console.error(`[Error] Write fail ${OUTPUT_CSS_FILENAME}`, e); }


    // --- Generation Summary ---
    console.log('\n--- Generation Summary ---');
    console.log(`Processed ${directoriesScanned} initial directories.`);
    const finalFamilyCountInternal = allFontFamilies.length; const finalVariantCountInternal = allFontFamilies.reduce((sum, f) => sum + f.variants.length, 0);
    console.log(`Successfully processed ${finalFamilyCountInternal} font families.`);
    console.log(`Found ${finalVariantCountInternal} total font variants.`);
    console.log(`Total original font file size: ${totalSizeMB_original} MB`);
    if (totalBase64Size > 0) { console.log(`Total Base64 data size generated: ${(totalBase64Size / (1024 * 1024)).toFixed(2)} MB`); }
    if (skippedFilesOrFolders > 0) { console.log(`Skipped ${skippedFilesOrFolders} directories/variants/families during processing.`); }
    console.log(`Output '${OUTPUT_INLINE_JS_FILENAME}' written with URL+Base64 data (${finalFamilyCount} families). Metadata flag 'base64Included': ${finalMetadata.base64Included}.`);
    console.log(`Output '${OUTPUT_JSON_FILENAME}' written with URLs only (${jsonOutput.metadata.familyCount} families).`);
    console.log('--- Done ---');
}

// --- Execute Script ---
try { generateFontsJson(); }
catch (error) { console.error("\n[Error] CRITICAL UNHANDLED EXCEPTION:", error); process.exit(1); }