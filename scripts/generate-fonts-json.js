/**
 * scripts/generate-fonts-json.js (v1.3 - Fixed JSON Path, Output CSS to Root)
 *
 * Scans the './fonts/' directory for font families.
 * Extracts metadata (weight, style, format).
 * Generates:
 * 1. `fonts.json`: Metadata with relative file paths (at project root). <--- FIXED PATH
 * 2. `inline-fonts-data.js`: JS variable, optionally with Base64 encoded fonts (at project root).
 * 3. `generated-font-classes.css`: CSS rules to apply font families (at project root).
 *
 * >>> IMPORTANT: 'scripts/build.js' MUST COPY 'generated-font-classes.css' from root to 'dist/<target>/css/' <<<
 *
 * Usage (from project root):
 * node scripts/generate-fonts-json.js          # Paths only + CSS rules
 * node scripts/generate-fonts-json.js --base64 # Base64 data + CSS rules
 */

const fs = require('fs');
const path = require('path');

// --- Configuration ---
const FONT_DIR_NAME = 'fonts';
const OUTPUT_JSON_FILENAME = 'fonts.json';
const OUTPUT_INLINE_JS_FILENAME = 'inline-fonts-data.js';
const OUTPUT_CSS_FILENAME = 'generated-font-classes.css'; // CSS output filename (now at root)
const FONT_FAMILY_CLASS_PREFIX = 'font-family-';
const SUPPORTED_FONT_EXTENSIONS = ['.otf', '.ttf', '.woff', '.woff2', '.eot'];
const LICENSE_FILENAMES = ['license.txt', 'license.md', 'license', 'readme.md', 'readme.txt', 'ofl.txt'];

// --- Path Setup ---
const PROJECT_ROOT = process.cwd(); // Use process.cwd() for reliability
const FONTS_DIRECTORY = path.resolve(PROJECT_ROOT, FONT_DIR_NAME);
// Corrected path for fonts.json to be at the project root
const OUTPUT_JSON_PATH = path.resolve(PROJECT_ROOT, OUTPUT_JSON_FILENAME); // <<< --- FIX APPLIED HERE
const OUTPUT_INLINE_JS_PATH = path.resolve(PROJECT_ROOT, OUTPUT_INLINE_JS_FILENAME);
// Output CSS to project root
const OUTPUT_CSS_PATH = path.resolve(PROJECT_ROOT, OUTPUT_CSS_FILENAME);

// --- Command Line Argument Processing ---
const args = process.argv.slice(2);
const includeBase64 = args.includes('--base64');
let generatedCssRules = `/* --- Generated Font Family Classes --- */\n/* Auto-generated by generate-fonts-json.js */\n\n`; // Initialize CSS string

// --- Helper Functions ---

function guessWeight(filename) {
    const lower = filename.toLowerCase().replace(/[-_\s]/g, '');
    const numericMatch = lower.match(/w(\d{3})/);
    if (numericMatch && numericMatch[1]) {
        const weight = parseInt(numericMatch[1], 10);
        if (weight >= 100 && weight <= 999) return weight;
    }
    const numericSeparatorMatch = lower.match(/(?:-|_)(\d{3})(?!.*\d)/);
    if (numericSeparatorMatch && numericSeparatorMatch[1]) {
        const weight = parseInt(numericSeparatorMatch[1], 10);
        if (weight >= 100 && weight <= 999) return weight;
    }
    const weightMap = {
        'extrablack': 950, 'ultrablack': 950, 'black': 900, 'heavy': 900,
        'extrabold': 800, 'ultrabold': 800, 'bold': 700, 'semibold': 600,
        'demibold': 600, 'medium': 500, 'regular': 400, 'normal': 400,
        'book': 400, 'light': 300, 'extralight': 200, 'ultralight': 200,
        'thin': 100, 'hairline': 100,
    };
    for (const [name, value] of Object.entries(weightMap)) {
        const regex = new RegExp(`\\b${name}\\b`, 'i');
        if (regex.test(lower)) return value;
    }
    return 400; // Default to regular
}

function guessStyle(filename) {
    const lower = filename.toLowerCase();
    if (/\bitalic\b|[-_\s]italic|^italic/i.test(lower)) return 'italic';
    if (/\boblique\b|[-_\s]oblique|^oblique/i.test(lower)) return 'oblique';
    return 'normal';
}

function formatDisplayName(name) {
    const spacedName = name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/[-_]/g, ' ');
    return spacedName.split(' ').filter(word => word.length > 0)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

function getMimeType(extension) {
    const lowerExt = extension.toLowerCase();
    const mimeTypes = { '.otf': 'font/otf', '.ttf': 'font/ttf', '.woff': 'font/woff', '.woff2': 'font/woff2', '.eot': 'application/vnd.ms-fontobject' };
    return mimeTypes[lowerExt] || 'application/octet-stream';
}

function convertFileToBase64DataUrl(filePath, format) {
    try {
        const fileData = fs.readFileSync(filePath);
        const base64Data = fileData.toString('base64');
        // Pass format *without* the leading dot
        const mimeType = getMimeType(`.${format}`);
        return `data:${mimeType};base64,${base64Data}`;
    } catch (error) {
        console.error(`[Error] Failed to read or encode file: ${filePath}`, error);
        throw error; // Re-throw to signal failure
    }
}

function isDirectory(dirPath) {
    try {
        return fs.lstatSync(dirPath).isDirectory();
    } catch (error) {
        if (error.code !== 'ENOENT') {
            console.warn(`[Warning] Could not stat path "${dirPath}": ${error.message}`);
        }
        return false;
    }
}

function sanitizeForClassName(name) {
    if (!name || typeof name !== 'string') return '';
    return name.toLowerCase()
               .replace(/[\s_]+/g, '-')
               .replace(/[^a-z0-9-]/g, '')
               .replace(/^[\d-]+/, '') || 'invalid-name';
}

// --- Main Generation Logic ---

function generateFontsJson() {
    console.log(`[Info] Starting font generation process...`);
    console.log(`[Info] Looking for font families in: ${FONTS_DIRECTORY}`);

    if (!isDirectory(FONTS_DIRECTORY)) {
        console.error(`[Error] CRITICAL: Main "fonts" directory not found at "${FONTS_DIRECTORY}".`);
        process.exit(1);
    }

    const allFontFamilies = [];
    let totalFilesProcessed = 0, totalFileSize = 0, totalBase64Size = 0;
    let skippedFiles = 0, directoriesScanned = 0;

    let fontDirs = [];
    try {
        fontDirs = fs.readdirSync(FONTS_DIRECTORY, { withFileTypes: true });
    } catch (error) {
        console.error(`[Error] CRITICAL: Could not read fonts directory "${FONTS_DIRECTORY}".`, error);
        process.exit(1);
    }

    const familyDirs = fontDirs.filter(d => d.isDirectory());
    directoriesScanned = familyDirs.length;
    console.log(`[Info] Found ${directoriesScanned} potential font family directories.`);
    console.log(`[Info] Base64 encoding: ${includeBase64 ? 'ENABLED' : 'DISABLED'}.`);

    familyDirs.forEach((subdir, index) => {
        const folderName = subdir.name;
        const absoluteFolderPath = path.join(FONTS_DIRECTORY, folderName);
        const relativeFolderPath = path.posix.join(FONT_DIR_NAME, folderName);
        console.log(`\n[Info] Processing [${index + 1}/${directoriesScanned}]: "${folderName}"`);

        let filesInDir;
        try {
            filesInDir = fs.readdirSync(absoluteFolderPath);
        } catch (error) {
            console.warn(`[Warning] Could not read directory "${absoluteFolderPath}". Skipping. Error: ${error.message}`);
            skippedFiles++;
            return;
        }

        const variants = [];
        let licenseFileRelativePath = null, licenseText = null;
        const formatsFound = new Set();

        filesInDir.forEach(file => {
            const absoluteFilePath = path.join(absoluteFolderPath, file);
            const fileExt = path.extname(file).toLowerCase();
            const format = fileExt.substring(1); // Format without dot

            if (SUPPORTED_FONT_EXTENSIONS.includes(fileExt)) {
                totalFilesProcessed++;
                let stats;
                try {
                    stats = fs.statSync(absoluteFilePath);
                    if (!stats.isFile()) throw new Error("Not a regular file");
                } catch (statError) {
                    console.warn(`[Warning] Could not stat font file "${path.join(relativeFolderPath, file)}". Skipping variant. Error: ${statError.message}`);
                    skippedFiles++;
                    return;
                }

                formatsFound.add(format);
                totalFileSize += stats.size;
                const weight = guessWeight(file);
                const style = guessStyle(file);
                const baseName = path.basename(file, fileExt);
                const variant = { name: baseName, weight, style, format, fileSize: stats.size };

                if (includeBase64) {
                    try {
                        // Pass format without dot to encoding function
                        variant.dataUrl = convertFileToBase64DataUrl(absoluteFilePath, format);
                        totalBase64Size += variant.dataUrl.length;
                    } catch (encodeError) {
                        console.warn(`[Warning] Failed to encode "${path.join(relativeFolderPath, file)}" to Base64. Skipping variant. Error: ${encodeError.message}`);
                        skippedFiles++;
                        return;
                    }
                } else {
                    variant.url = path.posix.join(FONT_DIR_NAME, folderName, file);
                }
                variants.push(variant);

            } else if (LICENSE_FILENAMES.includes(file.toLowerCase())) {
                if (!licenseFileRelativePath) {
                    licenseFileRelativePath = path.posix.join(FONT_DIR_NAME, folderName, file);
                    if (includeBase64) {
                        try {
                            licenseText = fs.readFileSync(absoluteFilePath, 'utf-8');
                        } catch (readError) {
                            console.warn(`[Warning] Could not read license file "${path.join(relativeFolderPath, file)}". Error: ${readError.message}`);
                            licenseText = `Error reading license: ${readError.message}`;
                        }
                    }
                }
            }
        }); // End looping through files in directory

        if (variants.length === 0) {
            console.warn(`[Warning] No valid font files found in "${folderName}". Skipping family.`);
            return;
        }

        const displayName = formatDisplayName(folderName);
        const familyName = displayName;
        variants.sort((a, b) => {
            if (a.weight !== b.weight) return a.weight - b.weight;
            const styleOrder = { normal: 0, italic: 1, oblique: 2 };
            const styleComparison = (styleOrder[a.style] || 9) - (styleOrder[b.style] || 9);
            if (styleComparison !== 0) return styleComparison;
            return a.name.localeCompare(b.name);
        });

        const familyObj = {
            displayName,
            familyName,
            variants,
            formats: Array.from(formatsFound).sort(),
            hasDefaultFont: variants.some(v => v.weight === 400 && v.style === 'normal'),
            fontCount: variants.length,
            totalSize: variants.reduce((sum, v) => sum + v.fileSize, 0),
        };
        if (licenseFileRelativePath) familyObj.licenseFile = licenseFileRelativePath;
        if (includeBase64 && licenseText !== null) familyObj.licenseText = licenseText;
        allFontFamilies.push(familyObj);

        // --- GENERATE CSS RULE ---
        try {
            const sanitizedClassName = sanitizeForClassName(familyObj.familyName);
            const cssClassName = FONT_FAMILY_CLASS_PREFIX + sanitizedClassName;
            const cssFontFamilyName = `"${familyObj.familyName}"`; // Always quote family name in CSS

            const lowerDisplayName = familyObj.displayName.toLowerCase();
            const isScript = lowerDisplayName.includes('script') || lowerDisplayName.includes('hand');
            const isSerif = ['serif', 'times', 'garamond', 'georgia', 'palatino'].some(serifWord => lowerDisplayName.includes(serifWord)) || /serif$/i.test(lowerDisplayName);
            const isMono = ['mono', 'console', 'courier', 'terminal'].some(monoWord => lowerDisplayName.includes(monoWord)) || /mono$/i.test(lowerDisplayName);

            let cssFallback = 'sans-serif';
            if (isMono) cssFallback = 'monospace';
            else if (isScript) cssFallback = 'cursive';
            else if (isSerif) cssFallback = 'serif';

            generatedCssRules += `.${cssClassName} {\n`;
            generatedCssRules += `  font-family: ${cssFontFamilyName}, ${cssFallback} !important;\n`;
            generatedCssRules += `}\n\n`;
        } catch (cssGenError) {
            console.warn(`[Warning] Failed to generate CSS rule for ${familyObj.familyName}:`, cssGenError.message);
        }
        // --- END CSS RULE GENERATION ---

    }); // End processing directories

    allFontFamilies.sort((a, b) => a.displayName.localeCompare(b.displayName));

    // --- Prepare Final Output Data ---
    const metadata = {
        generated: new Date().toISOString(),
        familyCount: allFontFamilies.length,
        totalFonts: allFontFamilies.reduce((sum, family) => sum + family.fontCount, 0),
        totalFileSizeMB: (totalFileSize / (1024 * 1024)).toFixed(2),
        base64Encoded: includeBase64,
        formatSummary: {}, // Will be populated below
        weightSummary: {}  // Will be populated below
    };

    // Calculate summaries (once, used by both output objects)
    const allFormats = new Set();
    const weightCounts = {};
    allFontFamilies.forEach(family => {
        family.formats.forEach(format => allFormats.add(format));
        family.variants.forEach(variant => {
            weightCounts[variant.weight] = (weightCounts[variant.weight] || 0) + 1;
        });
    });
    const formatSummary = {};
    allFormats.forEach(format => {
        formatSummary[format] = allFontFamilies.filter(f => f.formats.includes(format)).length;
    });
    const sortedWeightSummary = Object.fromEntries(
        Object.entries(weightCounts).sort(([a], [b]) => parseInt(a) - parseInt(b))
    );
    metadata.formatSummary = formatSummary; // Add to metadata object
    metadata.weightSummary = sortedWeightSummary; // Add to metadata object


    // Data specifically for fonts.json (excludes base64 data)
    const fontDataForJson = {
        metadata: { ...metadata }, // Use calculated metadata
        fonts: allFontFamilies.map(family => ({
            displayName: family.displayName,
            familyName: family.familyName,
            formats: family.formats,
            hasDefaultFont: family.hasDefaultFont,
            fontCount: family.fontCount,
            totalSize: family.totalSize,
            licenseFile: family.licenseFile,
            variants: family.variants.map(v => {
                const { dataUrl, ...rest } = v; // Exclude dataUrl
                // Ensure 'url' field exists (it should if includeBase64 is false)
                if (!includeBase64 && !rest.url) {
                    console.warn(`[Internal Warning] Missing URL for ${family.familyName} ${v.name} in non-Base64 mode.`);
                    // Construct a probable URL, matching the logic used when creating it
                    rest.url = path.posix.join(FONT_DIR_NAME, family.folderName || family.familyName.replace(/\s+/g, '-'), `${v.name}.${v.format}`);
                }
                return rest;
            })
        }))
    };

    // Data specifically for inline JS (includes base64 if requested)
    const fontDataForInline = {
        metadata: { ...metadata }, // Use calculated metadata
        fonts: allFontFamilies.map(family => {
            // If not including base64, structure should match fonts.json
            if (!includeBase64) {
                // Find the corresponding entry in fontDataForJson to avoid duplicating logic
                 const jsonFamily = fontDataForJson.fonts.find(f => f.familyName === family.familyName);
                 return jsonFamily || {}; // Return the JSON structure or empty if something went wrong
            } else {
                // If including base64, keep dataUrl and licenseText
                return {
                    displayName: family.displayName,
                    familyName: family.familyName,
                    formats: family.formats,
                    hasDefaultFont: family.hasDefaultFont,
                    fontCount: family.fontCount,
                    totalSize: family.totalSize,
                    licenseFile: family.licenseFile,
                    licenseText: family.licenseText, // Include license text
                    variants: family.variants.map(v => {
                        // Keep dataUrl, remove explicit url field if base64
                        const { url, ...rest } = v;
                        if (!rest.dataUrl) { // Should not happen if encoding succeeded
                            console.warn(`[Internal Warning] Missing dataUrl for ${family.familyName} ${v.name} in Base64 mode.`);
                            return null; // Filter out problematic variants later
                        }
                        return rest; // Contains dataUrl
                    }).filter(v => v !== null) // Filter out variants where encoding might have failed
                };
            }
        })
    };


    // --- Write Output Files ---
    try {
        console.log(`\n[Info] Writing ${OUTPUT_JSON_FILENAME} to project root...`);
        // Use 2 spaces for indentation in JSON for readability
        // OUTPUT_JSON_PATH is now correctly pointing to the root directory
        fs.writeFileSync(OUTPUT_JSON_PATH, JSON.stringify(fontDataForJson, null, 2), 'utf-8');
        console.log(`  [Success] Created ${OUTPUT_JSON_FILENAME} at project root.`);
    } catch (error) {
        console.error(`[Error] CRITICAL: Failed to write ${OUTPUT_JSON_FILENAME}`, error);
        throw error; // Re-throw error to stop the build process if this fails
    }

    try {
        console.log(`[Info] Writing ${OUTPUT_INLINE_JS_FILENAME} to project root...`);
        const inlineJsContent = `/** Generated by generate-fonts-json.js */\nwindow._INLINE_FONTS_DATA = window._INLINE_FONTS_DATA || ${JSON.stringify(fontDataForInline, null, 2)};\n`;
        fs.writeFileSync(OUTPUT_INLINE_JS_PATH, inlineJsContent, 'utf-8');
        console.log(`  [Success] Created ${OUTPUT_INLINE_JS_FILENAME} at project root.`);
    } catch (error) {
        console.error(`[Error] CRITICAL: Failed to write ${OUTPUT_INLINE_JS_FILENAME}`, error);
        throw error; // Re-throw error
    }

    // --- WRITE CSS FILE to ROOT ---
    try {
        console.log(`[Info] Writing generated font CSS rules to ${OUTPUT_CSS_PATH}...`);
        fs.writeFileSync(OUTPUT_CSS_PATH, generatedCssRules, 'utf-8');
        console.log(`  [Success] Created ${OUTPUT_CSS_FILENAME} at project root.`);
        console.warn(`  [Action Required Reminder] Ensure 'scripts/build.js' copies this CSS file to the correct 'dist/' location!`);
    } catch (error) {
        console.error(`[Error] CRITICAL: Failed to write ${OUTPUT_CSS_FILENAME}`, error);
        throw error; // Re-throw error
    }
    // --- END CSS FILE WRITE ---

    // --- Final Summary ---
    console.log('\n--- Font Generation Summary ---');
    console.log(`- Directories Scanned: ${directoriesScanned}`);
    console.log(`- Font Families Found: ${metadata.familyCount}`);
    console.log(`- Total Font Variants Processed: ${totalFilesProcessed}`);
    if (skippedFiles > 0) console.log(`- Files/Variants Skipped (Errors/Warnings): ${skippedFiles}`);
    console.log(`- Total Original File Size: ${metadata.totalFileSizeMB} MB`);
    if (includeBase64) {
        const base64SizeMB = (totalBase64Size / (1024 * 1024)).toFixed(2);
        console.log(`- Total Base64 Data Size: ${base64SizeMB} MB`);
        if (totalFileSize > 0) {
            const ratio = (totalBase64Size / totalFileSize).toFixed(2);
            console.log(`- Base64 Encoding Ratio: ~${ratio}x`);
        }
    }
    console.log(`- Detected Formats: ${Array.from(allFormats).join(', ') || 'None'}`);
    console.log(`- Output Files Generated at Project Root: ${OUTPUT_JSON_FILENAME}, ${OUTPUT_INLINE_JS_FILENAME}, ${OUTPUT_CSS_FILENAME}`);
    console.log('--- Process Complete ---');
}

// --- Execute ---
try {
    generateFontsJson();
} catch (error) {
    console.error("\n[Error] A critical error occurred during the font generation process:", error);
    process.exit(1); // Exit with error code
}